# 栈的应用场景

1. 子程序的调用：在跳往子程序之前，先将下个指令的地址存到堆栈当中，直到子程序执行完毕之后再将地址取出，回到原来的程序当中。
2. 处理递归调用：同子程序调用一样，除了存储下一条指令的地址之外，也将参数、区域变量等数据存入堆栈中。
3. 表达式的转换：[中缀表达式转为后缀表达式]
4. 二叉树的遍历
5. 图形的DFS

# 栈的实现

## 数组模拟栈的实现

1. 定义一个top来表示栈顶，初始化为-1
2. 入栈操作：当有栈加入到栈时，top++；stack[top]=data
3. 出栈操作：int value =stack[top],top--,return value

## 使用栈完成计算器（中缀表达式)

1. 数值栈：用来存放表达式的值
2. 符号栈：用来存放计算符号

思路：

1. index，用来对字符串进行扫描的索引
2. 如果我们发现是数字，则放入到数栈中
3. 如果发现是符号，分为如下的情况
   1. 如果符号栈中有操作符，则进行比较；当前操作符的优先级小于或等于栈中操作符的优先级，需要从数栈中pop出两个数，在符号栈中pop出一个符号并进行运算，可以得到结果。将得到的结果入数栈，并将当前的操作符入符号栈。
   2. 如果当前符号的优先级大于符号栈中符号的优先级，则直接进行入栈。
4. 当表达式扫描完毕，就按顺序从数栈和符号栈中pop出相应的数
5. 最后数栈中只有一个元素，就是运算的结果。

# 前缀表达式

前缀表达式又称为波兰表达式，运算符都位于操作数之前。

## 求值方式

从右至左扫描表达式。遇到数字时，将数字压入栈；遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应的计算（栈顶元素和次顶元素）并将结果入栈。重复以上过程直到表达式最左端。最后运算得出的值即为表达式的结果。

如：`(3+4)*5-6`对应的前缀表达式就是`- * + 3 4 5 6`

1. 从右至左扫描，将6、5、4,、3压入栈
2. 遇到`+`运算符，弹出3和4并计算3+4的值，将结果7压入栈
3. 遇到`*`运算符，弹出7和5，计算出`7 * 5`的值并将结果35压入栈
4. 遇到`-`运算符，弹出35和6，计算35-6的值得出结果为29

# 中缀表达式

中缀表达式是我们最常见的表达式，如`(3+4)*5-6`

中缀表达式的求值是我们最常见的，但是对于计算机来说却不好操作。

# 后缀表达式

逆波兰表达式。与前缀表达式相似，运算符位于操作数之后。

## 求值方式

从作至右扫描表达式。遇到数字时，将数字压入栈；遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应的计算（栈顶元素和次顶元素）并将结果入栈。重复以上过程直到表达式最右端。最后运算得出的值即为表达式的结果。
 
# 中缀表达式转后缀表达式

实现思路：

1. 初始化两个栈：运算符栈s1和存储中间结果的栈s2
2. 从左至右扫描中缀表达式
3. 遇到操作数，将其压入s2
4. 遇到运算符时，比较其与s1栈顶运算符的优先级
   1. 如果s1为空，或栈顶运算符为左括号`(`，则直接将此运算符入栈
   2. 否则，比较优先级。若优先级比栈顶运算符的高，也将运算符压入s1
   3. 否则，比较优先级。将s1栈顶的运算符弹出并压入到s2中，再次转到4.1与s1中心的栈顶运算符相比较
5. 遇到括号时：
   1. 如果遇到左括号`(`，则直接压入s1
   2. 如果遇到右括号`)`，则依次弹出s1栈顶的运算符，并压入s2；直到遇到左括号为止，此时将这一对括号丢弃。
6. 重复步骤2-5，直到表达式的最右边
7. 将s1中剩余的运算符一次弹出并压入s2
8. 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式0

例子：中缀表达式：1+((3+4)*4)-5

​			后缀表达式：1 2 3 + 4 * + 5 -