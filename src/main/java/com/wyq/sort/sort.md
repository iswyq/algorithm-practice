# 排序

1. 内部排序。所有的数据都要加载到内存中进行排序
2. 外部排序。将大量的数据（如10亿数据量）放在外存中进行排序。

## 时间复杂度

主要分为事后统计方法和事前估算方法。 

- 时间频度：一个算法中语句执行的次数。(一个算法中执行的语句越多，所花费的时间越长)
- 忽略常数项：时间复杂度就是算法中执行的语句数量。(特别注意循环时候的最后结果)
- 忽略低次项：当存在高次项时候，可以忽略低次项。

时间复杂度O(f(n)):即算法的基本语句执行的次数为T(n)，当T(n)/f(n)的极限值为一个不为零的常数，那么就可以说时间复杂度就是f(n)。

时间复杂度计算：

1. 
2. 
3. 计算出同阶的极限后，去掉最后阶的系数

通常，k次方阶主要出现在k重循环中。

线性阶(n):一个for循环

```java
for(n次){
    
}
```

对数阶(log2N):

```java
while(i<n){
    i=i^2;
}
```

线性对数阶(nlog2N):将时间复杂度为logn的代码循环N遍，那么得到的就是线性对数阶

```java
for(n次){
    while(i<n){
        i=i^2;
    }
}
```

立方阶，n次方阶就是多重for循环。

## 冒泡排序

排序规则：

1. 一共进行数组的大小`n-1`次大的循环
2. 每一趟排序的次数在逐渐减少
3. 如果我们发现在某趟的排序中，没有发生一次交换，则可以提前结束循环(代码优化)

原始数组：3,9，-1,10,20

1. 第一趟排序
   - 3,9，-1,10,20
   - 3，-1,10,20
   - 3，-1,10,20
   - 3，-1,10,20
2. 第二趟排序
   1. -1,3,9,10,20
   2. ....
   3. ....
   4. ....
3. ......

## 选择排序

思路：

1. 从`arr[0]~arr[n-1]`中寻找到一个最小的值。放第一个位置
2. 从`arr[1]~arr[n-1]`中寻找到一个最小的值。放在第二个位置
3. ...
4. 直到走到最后一个位置

说明:

1. 选择排序一共有数组大小`n-1`轮循环
2. 每一轮循环，又是一个循环
3. 先假定当前数是最小的数，然后与后面的数进行比较；如果发现有更小的数，那么重新确定最小的数

实现：

1. min用来保存最小的值
2. minIndex  用来保存最小值的索引（因为需要将最小值覆盖其他位置，数组的内部不能丢失；可以使得插入的元素与最小值互换即可  通过minIndex来实现）

## 插入排序

思路：

1. 将获得的数组中的第二个元素与前一个比较，获得排好序的数组
2. 将数组中第三个元素与前面的比较，(以此自前往后到第一个)
3. .....

最后获得一个排序序的数组。

实现：

1. 需要一个带插入的值  定义为insertVal  这个值就是要往前面已经排序完毕的数组中插入的值。
2. inertIndex  要插入到前面数组中的下标。从insertVal值所在的数组下标依次往前面找。直到找到数组的下标0

## 希尔排序

希尔排序也是一种插入排序  是经过改进的缩小增量排序。

思想：是将记录按下标的一定增量进行分组，对分组直接使用插入排序进行排序；随着增量的逐渐减少，   当增量减至1时，记录恰好被分为一组，算法终止。

![image-20220129123553427](C:\Users\WangYQ\AppData\Roaming\Typora\typora-user-images\image-20220129123553427.png)