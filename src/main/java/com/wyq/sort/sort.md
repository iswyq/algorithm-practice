# 排序

1. 内部排序。所有的数据都要加载到内存中进行排序
2. 外部排序。将大量的数据（如10亿数据量）放在外存中进行排序。

## 时间复杂度

主要分为事后统计方法和事前估算方法。 

- 时间频度：一个算法中语句执行的次数。(一个算法中执行的语句越多，所花费的时间越长)
- 忽略常数项：时间复杂度就是算法中执行的语句数量。(特别注意循环时候的最后结果)
- 忽略低次项：当存在高次项时候，可以忽略低次项。

时间复杂度O(f(n)):即算法的基本语句执行的次数为T(n)，当T(n)/f(n)的极限值为一个不为零的常数，那么就可以说时间复杂度就是f(n)。

时间复杂度计算：

1. 
2. 
3. 计算出同阶的极限后，去掉最后阶的系数

通常，k次方阶主要出现在k重循环中。

线性阶(n):一个for循环

```java
for(n次){
    
}
```

对数阶(log2N):

```java
while(i<n){
    i=i^2;
}
```

线性对数阶(nlog2N):将时间复杂度为logn的代码循环N遍，那么得到的就是线性对数阶

```java
for(n次){
    while(i<n){
        i=i^2;
    }
}
```

立方阶，n次方阶就是多重for循环。

## 冒泡排序

排序规则：

1. 一共进行数组的大小`n-1`次大的循环
2. 每一趟排序的次数在逐渐减少
3. 如果我们发现在某趟的排序中，没有发生一次交换，则可以提前结束循环(代码优化)

原始数组：3,9，-1,10,20

1. 第一趟排序
   - 3,9，-1,10,20
   - 3，-1,10,20
   - 3，-1,10,20
   - 3，-1,10,20
2. 第二趟排序
   1. -1,3,9,10,20
   2. ....
   3. ....
   4. ....
3. ......

## 选择排序

思路：

1. 从`arr[0]~arr[n-1]`中寻找到一个最小的值。放第一个位置
2. 从`arr[1]~arr[n-1]`中寻找到一个最小的值。放在第二个位置
3. ...
4. 直到走到最后一个位置