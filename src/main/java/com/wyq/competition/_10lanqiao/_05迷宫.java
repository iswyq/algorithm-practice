package com.wyq.competition._10lanqiao;

import java.util.*;

/**
 * @program: algorithm-practice
 * @description: 解答题迷宫
 * @author: Mr.Wang
 * @create: 2021-04-30 07:55
 **/
public class _05迷宫 {
    /*
     * 使用bfs进行搜索，然后进行路径回溯
     * bfs使用递归
     * */
    private static String BFS(int[][] arr, int row, int column) {
        // 定义可以走的方向：分别为上下左右
        int[][] step = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        String[] stepArr = {"U", "D", "L", "R"};
        // 用于记录是否被访问过的数组
        int[][] visit = new int[row][column];
        StringBuffer sb = new StringBuffer();//用于记录路径的字符船
        Stack<Node> stack = new Stack<>();//用于路径回溯
        // 放置队列 需要使用单向链表
        Deque<Node> queue = new LinkedList<>();
        // 新建初始化节点
        Node node = new Node(0, 0, -1, 0, 0, null);
        // 节点入队
        queue.offer(node);
    	/*只要这个队列中还有元素，那么就while循环会一直执行
			那么for循环也会一直执行，只是队列中的元素数量不会增加了。
    	*/
        while (!queue.isEmpty()) {
            Node head = queue.poll();//队列出队
            stack.push(head);//节点入栈
      /*现在能体会到这个栈的重要作用：因为我每次队列中的元素进行出队，
      如果没有一个地方来记录他们原来的顺序是怎样的，就会造成很多node丢失*/
            // 只要整个队列为非空，那么这个循环一直进行
            for (int i = 0; i < 4; i++) {//对这个点尝试四个方向走动
                String d = stepArr[i];
                int x = head.x + step[i][0];
                int y = head.y + step[i][1];
    			/*整个队列的变化过程：
						1.出一个元素，进来4个元素（如果有不符合要求的位置，入队将少于四个；最少为0个元素入队，最多为4个）
    			*/
                // 所有的位置遍历结束，对队列中的后续node进行遍历。此时队列是只出不进的状态
                // 在这里是有逻辑错误的，但是很奇怪为什么他们的不报错。
                if (x == row - 1 && y == column - 1 && arr[x][y] == 0 && visit[x][y] == 0) {
                    // 打印路径 包含队列中的node和栈中的node
					/*队列与栈中的元素转换过程：
						队列中的每一个元素出队进入到栈中。那么只要从栈中获取元素即可
					*/
					/*不对：
						为什么要将对这个栈的遍历放置在for循环中：
						因为栈只有可以走的通的位置（栈中的元素进行队中的元素）	
					*/
                    Node top = stack.pop();
                    int preX = top.preX;
                    int preY = top.preY;
                    sb.append(d);
                    sb.append(top.direction);
                    while (!stack.isEmpty()) {
                        // 只要栈不为空，那么该循环一直进行
                        top = stack.pop();
                        if (preX == top.x && preY == top.y) {
                            if (top.direction != null) {
                                sb.append(top.direction);
                                preX = top.preX;
                                preY = top.preY;
                            }
                        }

                    }
                    //只要这里return后，那么整个程序结束
                    return sb.reverse().toString();
                }
                // 继续bfs
                // 真的就是学到了，如果将x，y与0的大小判断的逻辑放在前面，如果不符合要求，那么后面对数组的条件判断就不会生效，这样不会触发IndexOutOfBoundsException这个运行时异常
                if (x >= 0 && x < row && y >= 0 && y < column && arr[x][y] == 0 && visit[x][y] == 0) {//条件：没有到最后一行、列；前面没有障碍物、下一个位置没有被访问过
                    /*当没有到达最后的一个位置的时候，且当前点向下一个点进行走是符合要求的，那么下一个点的Node加入队列*/
                    visit[x][y] = 1;//表示这个点已经访问过了
                    node = new Node(x, y, head.x, head.y, head.step + 1, d);
                    // node入队
                    queue.offer(node);
                }
                // System.out.println("");
            }
        }
        return null;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // 使用scanner进行数据的循环输入
        try {
            String s =
                    "01010101001011001001010110010110100100001000101010" +
                            "00001000100000101010010000100000001001100110100101" +
                            "01111011010010001000001101001011100011000000010000" +
                            "01000000001010100011010000101000001010101011001011" +
                            "00011111000000101000010010100010100000101100000000" +
                            "11001000110101000010101100011010011010101011110111" +
                            "00011011010101001001001010000001000101001110000000" +
                            "10100000101000100110101010111110011000010000111010" +
                            "00111000001010100001100010000001000101001100001001" +
                            "11000110100001110010001001010101010101010001101000" +
                            "00010000100100000101001010101110100010101010000101" +
                            "11100100101001001000010000010101010100100100010100" +
                            "00000010000000101011001111010001100000101010100011" +
                            "10101010011100001000011000010110011110110100001000" +
                            "10101010100001101010100101000010100000111011101001" +
                            "10000000101100010000101100101101001011100000000100" +
                            "10101001000000010100100001000100000100011110101001" +
                            "00101001010101101001010100011010101101110000110101" +
                            "11001010000100001100000010100101000001000111000010" +
                            "00001000110000110101101000000100101001001000011101" +
                            "10100101000101000000001110110010110101101010100001" +
                            "00101000010000110101010000100010001001000100010101" +
                            "10100001000110010001000010101001010101011111010010" +
                            "00000100101000000110010100101001000001000000000010" +
                            "11010000001001110111001001000011101001011011101000" +
                            "00000110100010001000100000001000011101000000110011" +
                            "10101000101000100010001111100010101001010000001000" +
                            "10000010100101001010110000000100101010001011101000" +
                            "00111100001000010000000110111000000001000000001011" +
                            "10000001100111010111010001000110111010101101111000";
            int[][] arr = new int[30][50];
            for (int i = 0; i < 30; i++) {
                for (int j = 0; j < 50; j++) {
                    // String s = scanner.nextLine();
                    // 需要通过这样的操作，将字符转换成数字
                    arr[i][j] = s.charAt(i * 50 + j) - '0';
                }
            }
            // 进行bfs
            // BFS(arr, 30, 50);
            System.out.println(BFS(arr, 30, 50));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // 新建一个节点类，用于表示每一个位置的信息以及放入到队列中
    static class Node {
        private int x;//当前位置x坐标
        private int y;//当前位置y坐标
        private int preX;//当前坐标的前一个位置x坐标
        private int preY;//当前坐标的前一个位置y坐标
        private int step;//记录走了多少步
        private String direction;//记录上一步的下一步怎么走的。比如从原点向下走一步，direction=D

        public Node(int x, int y, int preX, int preY, int step, String direction) {
            this.x = x;
            this.y = y;
            this.preX = preX;
            this.preY = preY;
            this.step = step;
            this.direction = direction;
        }
    }
}
