# 稀疏数组

当一个数组中大部分的元素为0，或者为同一个值的数组时候，可以使用稀疏数组来保存该数组。

**处理方法**

1. 第一行保存原数组的行数和列数、共有多少个有效值。
2. 后面记录有效值所在位置、值

**应用**

1. 数组的压缩。可以在五子棋程序中应用。

**结构**

- 列的结构基本不变，行动态变化。

| row  | col  | val  |
| :--: | :--: | :--: |
|      |      |      |
|      |      |      |
|      |      |      |

**二维数组转稀疏数组思路**

1. 遍历原始的二维数组，保存有效数据的个数sum
2. 根据sum创建稀疏数组 `int[sum+1][3]`
3. 将原始的二维数组存储到稀疏数组

**稀疏数组转二维数组思路**

1. 读取稀疏数组的第一行，创建二维数组
2. 读取稀疏数组的后几行，将数据填入到二维数组当中。

# 数组保存

- 使用BuffererWriter进行文件写入，需要传入一个writer对象
- 调用该对象的write方法将数组写入到一行中

```java
BufferedWriter writer = new BufferedWriter(new FileWriter(file.getCanonicalPath(), true));
for (int i = 0; i < arr.length; i++) {
    writer.write(arr[i][0] + "," + arr[i][1] + "," + arr[i][2] + ",");
}
```

# 数组读取

- 使用BufferedReader进行数据读入
- 调用该对象的ReadLine将所有的数据读入到一行
- 使用String的Split方法得到String的数组。
- 解析到int数组

```java
BufferedReader reader = new BufferedReader(new FileReader(file.getCanonicalPath()));
String s1 = reader.readLine();
String[] split = s1.split(",");
```

1. 先解析为稀疏数组
2. 解析为二维数组

# 队列

队列可以通过数组和链表来实现。

**数组实现**

- 队头指针front  随着输出而改变。 指向队头的前一个元素
- 队尾指针rear  随着输入而改变。 指向队尾元素
- 队列为空：front=rear  队列满：rear=maxSize-1  

**环形队列**

1. 将队头指针front指向到队列的第一个元素
2. 将队尾指针rear指向队列最后元素的后一个位置
3. 队列为满：(rear+1)%maxSize =front 
4. 队列为空：front =rear
5. 队列中有效值的个数：(rear+front-maxSize)%maxSize
6. 对队列的实现进行如上的修改即可实现环形队列

# 链表

链表包含data域和next域。在代码中没有显式结构，其结构存在于内存之中。

**链表的实现：**

1. 定义节点（head），指向单链表的头。需要一直保持不动。
2. 添加的节点放在链表的最后

**无顺序节点添加**

1. 找到当前链表的最后节点，将最后节点的next指向待添加的节点。（移动辅助节点，不移动指针 `temp.next`为空则表示当前temp代表的是链表最后的节点）
2. 循环查找链表的最后。使用while死循环，如果没有找到就将next指针后移。（需要通过一个辅助变量来实现遍历）
3. temp节点的移动

**有顺序添加节点**

在使用no进行判断时，容易出现空指针异常；那么使用if解决空指针异常问题。

1. 将待插入位置的前一个节点指向新节点。新节点指向后一个节点位置
2. 如果顺序no已经存在，则无法进行插入。

**节点删除**

1. 找到待删除节点的前一个节点，使用temp指向
2. 使temp指向待删除节点的后一个节点。
3. 没有被删除的节点jvm垃圾回收。

**链表显示**

链表没有一个显式结构，他的遍历和查询需要通过头结点一点一点向后进行。

1. while死循环。每拿到一个节点，进行一次打印。写上结束条件
2. 完成打印后节点向后移动

# 链表面试题

**返回倒数第k个节点 新浪**

1. 遍历一遍，确定整个链表的节点数sum
2. 使用for循环，遍历`sum-index`次

**单链表反转(有难度) 腾讯**

1. 定义一个头结点reverseHead，遍历链表；每个节点放置在reverse节点的前面。（这里front和next在外界看来的结构是一样的）
2. 将head的next指向reverseHead。

**将链表进行逆序打印 百度**

1. 将链表进行遍历，并压入栈中。
2. 对压入的元素进行出栈。

# 双向链表

单向链表只能从前向后进行遍历。单向链表不能进行自我删除。

双向链表可以对上述两个缺点进行补充

**双向链表的遍历**

1. 与单向链表的遍历完全一致。

**双向链表的节点增加**

1. 将增加的节点放在链表的最后
2. temp.next=newNode   newNode.pre=temp

**双向链表节点的删除**

1. 可以进行节点自身的删除
2. temp.pre.next = temp.next    temp.next.pre = temp.pre(可能存在空指针异常  如果待删除的节点是链表的最后节点)

**双向链表按照编号顺序进行添加**

# 约瑟夫环（Josepf）

n个节点形成一个环形链表，从第一个节点开始数m，第m个节点删除。从第m+1个节点开始继续数m个节点；进行删除；以此类推....

**构建单向环形链表**

1. 先创建第一个节点，让first指向该节点，并形成环形。
2. 后面创建的新一个节点，加入到已有的环形链表中。

**遍历环形链表**

1. 先让一个辅助指针cur，指向first节点
2. 然后通过while循环遍历环形链表  当cur.next指向first节点时，表示遍历完成。
